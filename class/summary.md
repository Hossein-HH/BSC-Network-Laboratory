## جلسه اول 30-11-1401 (آشنایی با Router)
### دستگاه `Router`
* استفاده از `Router 1841`
* برای بررسی اتصالات و وضعیت کلی `Router` از Hover کردن موس روی آن کمک می‌گیریم
* در پشت `Router` تعداد 4 عدد Interface با رنگ های مختلف قرار داد:
    - رنگ زرد: `FE(Fast Ethernet)`
    - رنگ آبی: `Console`
    - رنگ خاکستری: `AUX` یا همان آگزیلاری که پورت پشتیبان برای استفاده در صورت خرابی پورت کنسول می‌باشد.
* اصولا رنگ آبی به نوعی استانداری برای نشان دادن کابل و یا پورت `Console` می‌باشد.
* وظیفه کابل `Console` در واقعیت به ما دسترسی ای را می‌دهد که در CPT با کلیک بر روی دیوایس و انتخاب تب `CLI` می‌توانیم داشته باشیم.
* اصطلاح `Hyper Terminal` برای روتر در واقعیت به کار می‌رود به جای `CLI`.
* برای اضافه کردن ماژول، خاموش کردن `Router` فراموش نشود.
* برای افزودن پورت `FE` به `Router 1841` از ماژول `WIC-1ENET` استفاده می‌کنیم.
* در تب مربوط به `Router` ماژول ها را پس از انتخاب و کلیک روی ماژول مورد نظر علاوه بر نوار سمت چپ از روی اسم آنها؛ از روی عکس نمایش داده شده از ماژول در قسمت پایین سمت راست نیز می‌توانیم اضافه کنیم.
* برای حذف ماژولهای اضافه شده کافیست آنها را خلاف مرحله فوق به جای که از آن آوردیم بکشیم.
* بعد از اعمال تغییرات روی ماژول ها می‌توان با Hover کردن موس روی `Router` مجددا از صحت اتصال ماژول ها مطمئن شد.
* در باکسی که موقع Hover روی `Router` نمایش داده می‌شود؛ بعد از اسم ماژول اضافه شده 3 عدد به ما نشان می‌دهد که عدد وسط نشان دهنده شماره `Slot` ای هست که ماژول روی آن قرار دارد.
* وقتی برای بار اول یک `Router` خام رو روشن می‌کنیم اگه تنظیمات نداشته باشه عبارت `Continue with configuration dialog? [yes/no] : ` برای راهنمایی در ست کردن برخی مقادیر شبیه راه اندازی اولیه پس از نصب ویندوز به ما نمایش می‌دهد و ما به دلیل اینکه با خیلی موارد کار نداریم همان `No` را می‌زنیم یا اصطلاحا از این مراحل skip می‌کنیم.
* در `CLI` عبارت `RETURN` معدل همان Enter است.
* لینوکس توی بازار کار خیلی نیاز هست.
* استاد وقتی میگن کجا هستید ؟ یعنی اعلانمون کجاست؟ و اعلانه خودمون رو بخونیم.
* در اولین مرحله اعلانمون `Router>` هست و به اصطلاح در این مرحله قرار داریم مشابه Directory در terminal سیستم عامل‌ها.
* خیلی از کامند‌هایی که در دنیای واقعی وجود دارند در محیط CPT جوابگو نیستن و این مسئله عادی هست چون سیسکو این بستر رو رسیدن به مرحله متوسط ایجاد کرده و برا کار به صورت حرفه‌ای تر می‌بایست یک دستگاه `Router` تهیه کرد.
* در CPT به طور پیش فرض Interface های ما خاموش هستند.

##  جلسه دوم 07-12-1401 (آشنایی با پیاده سازی یک توپولوژی ساده تنظیم رمز عبور برای اجرای دستور enable و آشنایی با Telnet)
* کابل `Serial` فقط برای ارتباط `Router` به `Router` استفاده میشود.
* در این درس ما از `Switch 2950` استفاده می‌کنیم که 24 پورت دارد.
* برای شناساندن یک `Router` به یک `End device` هنگام IP دهی دستی علاوه بر `IP` و `Subnet Mask` باید `Default Gateway` را هم وارد کنیم.
* مقدار `Default Gateway` برای `End device` همان `IP` مربوط به `Interface` متصل به `Router` می‌باشد. 
  

## جلسه سوم 14-12-1401 (مسیریابی دستی)
* تعیین `Default Gateway` برای End device ها برای ارتباط با دستگاه های دیگر ضروری می‌باشد.
* مقدار `Default Gateway` در اصل همان IP اولین Router متصل به End device مد نظر می‌باشد.
* در `Router` هم می‌توان Ping گرفت.

###  مسیر یابی دستی یا Static یا IP Route
1. تشخیص تعداد زیر شبکه های موجود در شبکه
2. تشخیص و تفکیک تعداد زیر شبکه‌های آشنا برای `Router` مد نظر (آن دسته از زیر شبکه‌های یرا که می‌شناسد گه هیچ ولی آن دسته از زیر شبکه هایی را که نمی‌شناسد برای `Router` معرفی می‌کنیم.)
* هر `Router` زیرشبکه‌هایی که بدون واسطه‌ی یک `Router` دیگر و به طور مستقیم به `Interface` های آن متصل هستند را می‌شناسد و نیازی به معرفی آنها نیست.
3. به ازای هر زیرشبکه‌ای که `Router` مد نظر نمی‌شناسد باید یک `Static Route` تعریف کنیم.
* گام بعدی یا اصطلاحا `Next Hop` برای هر `Router` میشود IP اولین Interface.
* مکانیزم این مسیریابی به این شکل است که اگر حاصل AND دو مقدار `IP بسته‌ی دریافتی` و `destination Sunbet Mask` برابر شد با `destination Net-ID` آن بسته به `Next Hop` ارسال می‌شود.
* هیچ وقت منظور از `Next Hop` یکی از `Interface` های `Router` ای که در حال config آن هستیم نیست منظور گام بعدی از Router جاری هست.
4. با کمک دستور `ip route + destination Net-ID + destination SubnetMask + next Hop` مسریابی دستی را برای زیرشبکه‌های ناشناخته برای هر Router به صورت جداگانه انجام می‌دهیم.
5. با کمک دستور `show ip route` می‌توانیم مسیریابی های دستی انجام شده را مشاهده کنیم.
* با کمک دستور `show ip interface brief` می‌توانیم مشخصات `Interface` های `Router` را مشاهده کنیم.

### کلاس‌های IP
* یک IP از 4 بخش تشکیل شده که به اختصار به این شکل نوشته می‌شود: `W.X.Y.Z`
* تنها ملاک ما برای تعیین کلاس یک IP بخش اول آن یا همان `W` هست.
```
Class A: 001 ≤ W ≤ 126
Class B: 128 ≤ W ≤ 191
Class C: 192 ≤ W ≤ 223 
```

### محاسبه Subnet Mask
* در اصل `Subnet Mask` یک تعداد مشخص(24 رقم) `0, 1` پشت سر هم می‌باشد که به هیچ عنوان `0` بین `1`ها قرار نمی‌گیرد.
* معمولا Subnet Mask را به صورت `K/` نمایش می‌دهیم که `K` نمایانگر تعداد `1`های پشت سر هم می‌باشد.
* می‌توان در مواردی که معادل Binary عددی بزرگ و نزدیک به `255` می‌شود معادل `Not` آن عدد را حساب کرد و از `255` کم کرد در نتیجه حاصل با معادل Binary عدد مطلوب یکسان می‌شود.


## جلسه چهارم 21-12-1401 (تعیین IPهای داخل یک زیر شبکه)
### مواردی که به اشتباه اطلاق می‌شود
+ ~~در یک کلاس IP بودن~~
+ ~~یکی بودن Subnet Mask~~

### فرمول محاسبه `Net ID` 
___
`Net ID = IP & Subnet Mask`
___


+ **تنها معیار برای تعیین IP های داخل یک زیرشبکه مقایسه `Net ID` آنها می‌باشد.**
+ هیچ وقت روی یکسان بودن `Subnet mask`ها حساب باز نشود زیرا این امکان وجود دارد که رقم آخر یا ارقام آخر که بین 2 IP مورد اختلاف هست خارج از دامنه ثابت `Subnet Mask` باشد.

### فرمول محاسبه `Subnet Mask` از روی `k/` 
---
+ برای تبدیل `Subnet Mask` از حالت `Wildcard Mask` به حالت Binary می‌توانیم از این فرمول استفاده کنیم:
```
/k ---> k ~/ 8 = n ---> ((255.) * n) + (k % 8)

/17 ---> 17 ~/ 8 = 2 ---> ((255.) * 2) + (1) 
---> 11111111.11111111.10000000.00000000
---> 255.255.128.0
```
+ `~/` نماد تقسیم فقط با در نظر گرفتن خارج قسمت است.
+ `%` نماد تقسیم فقط با در نظر گرفتن باقی‌مانده است.
+ `+` نماد الحاق 2 رشته است.
---

* بخش هایی از `Subnet Mask` که برابر با 255 نیستند را `بخش های موثر` در محاسبه `Net ID` در نظر می‌گیریم (منظور یکی یا چند `Segment` از `W.X.Y.Z` هست).
* اگر یخش‌های موثر از `Subnet Mask` با معادل آنها در `IP` همپوشانی نداشتند معادل آن بخش ها در `Net ID` برابر با `0` می‌شود در غیر این صورت باید متناسب با جایگاه قرار گیری عدد یا اعداد همپوشان معادل Binary آن‌ها را حساب کرد و برای `Net ID` در نظر گرفت.
* فقط به بخش `Z` در `Subnet Mask` توجه نشود زیرا که بخش‌های دیگر نیز ممکن است مؤثر باشند و یا تغییر پیدا کرده باشند نسبت به `IP` دیگر.
* توصیه به کار کردن با اعداد کوچک‌تر است زیرا که محاسبه آن‌ها راحت‌تر بوده و همچنین معادل استاندارد‌های آرایه‌ها در برنامه‌نویسی که از اندیس اول شروع به پر کردن می‌کنند لحاظ می‌شود.

### چند قانون بسیار مهم
---
1. تمام دستگاه‌هایی که به یک یا چند سوئیچ متصل هستند(که همگی به یک `Router` متصل‌اند) در یک `IP Range` قرار دارند.
2. در یک `Router` تمامی `Interface`ها باید به گونه‌ای IP دهی شوند که `Net ID` آن‌ها منحصر به فرد(یکتا) یا اصطلاحا `Unique` باشند.
> * جهت تعیین `Net ID` یکتا برای `Interface`های یک `Router` بهتر است بخش اول `IP` یا همان `W` را تغییر دهیم.
3. هر 2 سر از یک کابل باید داخل یک زیرشبکه باشند(اصطلاحا `Net ID` آنها برابر باشد).
---
### مفاهیم `Host ID`, `Net ID`
1. تمام فضای 32 بیتی `IP` به 2 قسمت (`Host ID`,`Net ID`) تقسیم می‌شود.
2. تعداد `1`های `Subnet Mask` برابر میشه با تعداد بیت های `Net ID`.
3. طبق قانون عنوان شده در خط بالا با کم کردن تعداد بیت‌های `Net ID` از عدد `32` می‌توان تعداد بیت‌های `Host ID` را محاسبه کرد.
```
<-------- 32 bits -------->
<---Net ID---><--Host ID-->
```
4. فرآیند `IP` دهی نباید بگونه‌ای باشد که تمام `bit`های `Host ID` صفر `0` یا یک `1` باشد.
5. با رعایت قانون فوق می‌توان علاوه بر نوشتن تمام `IP`های ممکن بدون همپوشانی با `Subnet Mask` از `IP`هایی که `1`های Binary آن‌ها با `Subnet Mask` نیز همپوشانی دارند استفاده کرد:
```
/30:

10.20.30.0 =>   (Host-ID = 00)   => ❌
10.20.30.1 =>   (Host-ID = 01)   => ✅
10.20.30.2 =>   (Host-ID = 10)   => ✅
10.20.30.3 =>   (Host-ID = 00)   => ❌
10.20.30.4 =>   (Host-ID = 00)   => ❌
10.20.30.5 =>   (Host-ID = 01)   => ✅
10.20.30.6 =>   (Host-ID = 10)   => ✅
```
6. تعداد کامپیوتر‌هایی که بر اساس یک `Subnet Mask` به عنوان مثال `k/` می‌تواند در یک زیرشبکه(یا همان `Net ID`) قرار بگیرند برابر است با:
```
2^(32-k) -2
```
## جلسه پنجم 20-01-1402 (آدرس‌دهی پیش فرض `Default Routing`)
* از `Default Routing` فقط زمانی می‌تونیم استفاده کنیم که `Router` مد نظرمون فقط یه راه به سمت زیرشبکه‌هایی که نمی‌شناسد داشته باشد.
* به عبارتی دیگر به ازای تمام `Net ID`ها به سمت یک `Next Hop` هدایت شود(به طور خلاصه میتوان گفت با استفاده از این روش کار `Copy` ‌ `Past` های بیهوده و اضافی را با یک دستور انجام می‌دهیم)
> نکته بسیار مهم این قضیه این است که در صورت استفاده از این نوع آدرس دهی تمام درخواست‌ها به سمت یک `Interface` می‌رود در نتیجه تنها در صورتی مجاز به آدرس دهی پیش فرض هستیم که تمام `Next Hop` برای تمامی `IP route`ها یکی باشد.
```cisco
R2(config)# ip route "Net ID" "Subnet Mask"  "Next Hop"
--------------------------------------------------------
R2(config)# ip route  0.0.0.0    0.0.0.0    192.168.20.1
--------------------------------------------------------
```
* دستور فوق معادل است با تمام دستورات زیر: 
```cisco
R2(config)# ip route     "Net ID"     "Subnet Mask"    "Next Hop"
-------------------------------------------------------------------
R2(config)# ip route   192.168.10.0   255.255.255.0   192.168.20.1
R2(config)# ip route   192.168.30.0   255.255.255.0   192.168.20.1
R2(config)# ip route   192.168.50.0   255.255.255.0   192.168.20.1
-------------------------------------------------------------------
```
## جلسه ششم 10-02-1402 (آدرس‌دهی با پروتکل `RIP`)
* تنظیمات پروتکل‌ها به طور کلی از تنظیمات دستی راحت تر است.
* پروتکل‌ها شبیه توابع در برنامه نویسی هستند از کتابخانه هایی آماده.
* زیاد بودن تعداد `Router`ها در مسیریابی های پیش‌فرض چالیش برانگیز خواهد بود.
* در پروتکل‌ها هر `Router` اطلاعات خودش که شامل همون زیر‌شبکه‌های متصل به خودش میشه رو با بقیه `Router`ها به اشتراک میزاره و به این شکل پس از گذشت یه مدت زمان همه `Router`ها از تمام زیرشبکه‌های موجود در شبکه اطلاع خواهند داشت و در ضمن این اطلاعات به روز رسانی می‌شوند پس از یک زمانی.
* این زمان به روزرسانی نیز قابل تنظیم هست.
* در مدل های دستی عملیات به‌روزرسانی متداوم رو نداریم و فقط در صورت تغییر اساسی مانند قطع شدن کانال بین دو `Router` باید تغییرات را به صورت دستی اعمال کنیم.
* مشاهده جدول مسیریابی با دستور `show ip route`.
* تمامی `Router`ها زیرشبکه‌های متصل بهشون رو می‌شناسند و اطلاعاتشون رو به همه `Router`ها می‌دهند(به صورت انتقال بین همسایه های دیوار به دیوار هر `Router` فقط به `Router`های متصل به خودش اطلاعاتش رو میفرسته).
* بعد از یه مدت زمان این اطلاعات بین همه پخش میشه و همه `Router`ها اطلاعات رو به روز میکنند.

### انواع پروتکل‌ها
#### 1. پروتکل‌های Classfull
موقع محاسبه `Net ID` هیچ توجهی به `Subnet Mask`های تنظیم شده ما ندارد و از `Subnet Mask` مربوط به `Class`های استاندارد استفاده می‌کند.
```cisco
 Class |   "Subnet Mask"    |    "Subnet Mask"
--------------------------------------------------
   A   |        /08         |    255. 0 . 0 .0
   B   |        /16         |    255.255. 0 .0
   C   |        /24         |    255.255.255.0
--------------------------------------------------
```
#### 2. پروتکل‌های Classless
این پروتکل‌ها اجباری برای استفاده از استاندارد فوق در نظر ندارند و با `AND` کردن `IP` و `Subnet Mask` ای که کارشناس شبکه در نظر گرفته است نیز میتوان `Net ID` را محاسبه نمود.

* در این درس برای پروتکل‌های `OSPF`,`EIGRP` از حالت `Classless` آنها و برای پروتکل `RIP` از حالت `Classfull` آن استفاده می‌کنیم.
  
برای استفاده از پروتکل `RIP` جهت مسیریابی به صورت زیر عمل میکنیم:
```cisco
>> STEP 1:

R1(config)# router "Protocol name"
----------------------------------
R1(config)# router      rip

>> STEP 2:

R1(config-router)# network "Known Net IDs"
------------------------------------------
R1(config-router)# network  192.168.10.0
R1(config-router)# network  192.168.20.0
R1(config-router)# network  192.168.30.0
```

## جلسه هفتم 17-02-1402 (آدرس‌دهی با پروتکل `EIGRP`)
* پروتکل `EIGRP` یک پروتکل مخصوص شرکت سیسکو بود که بعد از مدتی به صورت `Open Source` منتشر شد.
* پروتکل `EIGRP` یک پروتکل `Classless` است. یعنی میتواند از `Subnet Mask` های مختلفی استفاده کند.
* پروتکل `EIGRP` خیلی گسترده هست و خیلی قابلیت‌های زیادی دارد به عنوان مثال 5 فاکتور برای بهینگی دارد قابلیت وزن دهی به فاکتور‌ها و همچنین قابلیت `Load balancing` خیلی خوبی دارد اما در این درس به تدریس پایه‌ای ترین تنظیمات یعنی صرف `Ping` گرفتن س اکتفا می‌شود.
* این قانون در پروتکل ها عوض نمیشه که هر `Router` باید `Interface`هایی که بهش Connect هستند را اعلام کند با زدن دستور ` network #`.
* در این پروتکل `Autonomous Systems` را نیز باید مقدار دهی کنیم که یک عدد دلخواه و انتخابی هست منتهی باید این عدد در ناحیه‌هایی که مد نظر داریم با این پروتکل کار بکنند مشترک باشد مثلا اگر در یک `Router` عدد `100` را انتخاب کردیم برای بقیه `Router`ها نیز باید عدد `100` را انتخاب و اعمال کنیم.
* عدد `Autonomous Systems` به اختصار `as` نیز نامیده می‌شود.
* معنی این مکانیزم به این شکل است که  تمامی `Router`هایی که یک `as` دارند در یک ناحیه خود مختار قرار می‌گیرند.

دستورات این پروتکل به شکل زیر است:
```cisco
>> STEP 1:
                    "protocol"    "as"
---------------------------------------
R1(config)# router    eigrp       100

>> STEP 2:
                                  "Net ID"        "Wild Card Subnet Mask"
--------------------------------------------------------------------------
R1(config-router)# network      192.168.10.0             0.0.0.3
```

> یک قابلیت خیلی خوب در تنظیمات پروتکل ها این است که نیازی به محاسبه Net ID ندارند به این شکل که میتوان به جای محاسبه Net ID از IP همان Interface از Router که به زیرشبکه مورد نظر متصل است که قصد محاسبه Net ID آن را داریم استفاده کنیم و همچنین به جای محاسبه Wild card address همان subnet mask معمولی را بنویسیم که به طور مثال با اعمال این نکات میتوان دستور network فوق را بدین شکل نیز نوشت:
```cisco
                             "R1 interface IP"        "Subnet Mask"
--------------------------------------------------------------------------
R1(config-router)# network      192.168.10.2         255.255.255.252
```

> به طور کلی برای پاک کردن یک دستور از تنظیمات از دستور `no` استفاده می‌کنیم و در لایه‌ی بالاتر هم این عمل قابل انجام هست یعنی مثلا برای پاک کردن یک پروتکل از تنظیمات یک `Router` از دستور `no router` استفاده می‌کنیم به جای `no network` که در لایه‌ی پایین‌تر استفاده می‌شود.

## جلسه هشتم 24-02-1402 (آدرس‌دهی ترکیبی و پروتکل `OSPF`)
* جهت حفظ تنظیمات `Router` و جلوگیری از، از بین رفتن تنظیمات پس از خاموش و روشن شدن از دستور `config startup-config` استفاده میکنیم.
* پروتکل ها درکنار یکدیگر نیز کار میکنند.
* در این مرحله `Default Routing` را با `eigrp` ترکیب میکنیم.
* برای آخرین `Router` که از شبکه محلی `LAN` به `ISP` متصل است از `Default Routing` استفاده میکنیم.
* برای انجام عملیات فوق از دستور `R1(config)# ip route 0.0.0.0 0.0.0.0 ${Next Hop}` استفاده میکنیم.
* این کار را برای `Router` فرضی ISP که در توپولوژی مربوط به این جلسه قابل مشاهده هست انجام می‌دهیم.
* نکته خیلی مهم این سناریو این است که وقتی از دو پروتکل و دو نوع مسیریابی به طور کلی استفاده می‌شود که از یک جنس نیستند بنابراین از دستور `R1(config-router)# redisribute static` استفاده میکنیم تا به روتر بگوئیم که جدول مسیریابی را مجددا `Router` کن و این نکته رو هم در نظر داشته باش که یک دستور `static route` به کار برده ایم و این دستور را نیز علاوه بر جداول مسیریابی‌ات ارسال کن.

### پروتکل `OSPF`
* پروتکل `OSPF` یک پروتکل `Classless` می‌باشد.
* پروتکل های `Classless` همانطور که قبلا اشاره شده بود با `Subnet Mask` ای که ما در زیر شبکه‌ها اعمال می‌کنیم کار می‌کنند.
* این پروتکل شباهت زیادی به پروتکل `EIGRP` دارد فقط در انتهای دستور تعریف `network`های  آن یک پارامتر به نام `Area` نیز دارد.
* پروتکل `OSPF` از مسیریابی های سلسله مراتبی پشتیبانی می‌کند
* به صورت پیش فرض همه `Router`ها در `area 0` قرار دارند.  
* اگر موقع امتحان یا دستور کارها `area` ندید باید همان مقدار پیش فرض که صفر می‌باشد در نظر گرفته شود.
* تعریف پروتکل بدین شکل صورت میگیرد: `R1(config)# router ospf 100`
* تعریف `network`های نیز همانطور که پیشتر اشاره شد بدین شکل انجام می‌گیرد: `network ${net-id/inteface ip} ${(wild-card/normal)subnet-mask} area 0`

## جلسه نهم 31-02-1402 (`MultiArea OSPF`)
* در این مدل مسیریابی همانطور که از نامش پیداست از چندین `Area` استفاده می‌شود.
* در این مدل `Router`ها به 2 دسته تقسیم می‌شوند:
  * دسته اول: `Router`هایی که در یک `Area` قرار دارند.
  * دسته دوم: `Router`هایی که در بیش از یک `Area`قرار دارند. که `Router`های مرزی نیز شامل این دسته می‌شوند.
* تعریف زیرشبکه‌ها دقیقا مشابه حالت `Area 0` در `OSPF` ساده هست منتهی تنها تفاوتی که وجود دارد این هست که هنگام تعریف زیر‌شبکه‌ها به جای `Area 0` از شماره `Area` مورد نظر استفاده می‌کنیم.

+ برای امتحان در باب ترکیب پروتکل‌ها فقط از ترکیب `EIGRP`  و `IP Route` سوال می‌آید طبق دستور کار‌های قبلی.

## جلسه دهم 07-03-1402 (پیکر بندی `VLAN` ساده)
* این موضوع را می‌دانیم که به صورت پیش فرض هنگامی که دو یا چند `Host` به یک `Switch` متصل هستند هیچ تفاوتی نمی‌کند که `Host`ها به کدام پورت از سوئیچ متصل هستند.
* دلیل اتفاق فوق نیز این موضوع می‌باشد که تمام دستگاه‌ها در یک `VLAN` قرار دارند.
* برای تنظیم `VLAN` ابتدا دستگاه‌ها را به پورت های مورد نظرمان در `Switch` متصل می‌کنیم.
* سپس وارد `Switch` شده و پیکربندی آن را بدین شکل انجام می‌دهیم:
* 1. مشابه دستگاه `Router` با کمک دستور `enable` دسترسی `admin` می‌گیریم.
* 2. با وارد کردن دستور `Switch# show vlan` جدول `VLAN`ها را بررسی می‌کنیم و پورت‌های مورد نظر را انتخاب می‌کنیم.
* 3. به صورت پیش فرض دستگاه `Switch` یک `VLAN` با نام `default` دارد که تمامی پورت‌ها را نیز در آن قرار می‌دهد.
* 4. سپس دستور `Switch# conf t` را وارد می‌کنیم.
* 5. سپس با دستور `Switch(config)# vlan ${vlan-id}` یک `VLAN` جدید تعریف می‌کنیم.
* 6. سپس اسم مورد نظر را با دستور `Switch(config-vlan)# name ${name}` به `VLAN` مذکور اعطا می‌کنیم.
* 7. برای بررسی صحت اعمال دستورات وارد شده از دستور `Switch# sh vl` استفاده می‌کنیم.
* 8. برای تنظیم `VLAN` روی یک `Interface` از دستور `Switch(config)#in ${in name like f0/10}` استفاده می‌کنیم.
* 9. برای تخصیص `Interface`ای که انتخاب شده به `VLAN` مذکور از دستور `Switch(config-if)# sw ac vl ${vlan-id}` استفاده می‌کنیم.
* 10. حال اگر جهت گرفتن پینگ میان 2 یا چند دستگاهی که آنها را در `VLAN`های متفاوت قرار دادیم اقدام کنیم قاعدتا در صورتی که تنظیمات را به درستی وارد کرده باشیم باید تمام پکت ها `loss` شوند و پینگ میان دستگاه‌ها برقرار نشود.
* 11. در انتها به عنوان آخرین دستوری که در `Switch` وارد می‌کنیم و با دستور `Switch(config-if)# sw mo tr` یکی از پورت‌های که در `Switch` آزاد هست را به حالت `Trunc` ببریم.
> * با فعال کردن حالت `Trunc` در `Switch`  برای بسته‌هایی که مقصد و مبدا هایی که داخل چند `VLAN` مجزا قرار دارند امکان برقراری ارتباط بین `VLAN`ها را از طریق خارج کردن بسته ها از حالت `Trunc`  در سوئیچ  و هدایت آنها به سمت `Router`  فراهم می‌کنیم.

> * نکته ای که در این قسمت بسیار مهم هست این است که باید حتما همان پورتی که با کابل به `Router` وصل شده است را در حالت `Trunc` قرار دهیم.

* 12. حال با زدن دستور `Switch# sh r` می‌توانیم گزارشی از وضعیت کلیه‌ی پورت ها داشته باشیم اعم از تنظیمی که برای `Trunc` انجام دادیم تا تنظیمات مربوط به `VLAN`ها. 

## جلسه یازدهم(آخر) 07-03-1402 (ادامه پیکر بندی `VLAN` ساده)
* هنگام شمارش `LAN`های یک `Router` باید حتما حواسمان باشد که `VLAN`ها را نیز بشماریم.
* هنگام تعریف `VLAN`ها به ازای هر `VLAN` باید یک `Sub Interface` تعریف کنیم.
* همانطور که زیر شبکه ما مجازی هست در `VLAN` اون `Interface` ای که به عنوان `Default Gateway` هست نیز باید مجازی باشد در نتیجه از `Sub Interface`ها استفاده می‌کنیم.
* برای تعریف `Sub Interface` از دستور `Router(config)# in fa0/0.${sub-inf-id like 10}` 
* پس از وارد کردن دستور فوق باید اعلان ما با `Router(config-subif)#` یکسان باشد.
* حال `Sub Interface`ای را که ایجاد کردیم مسئول `VLAN` مربوطه می‌کنیم و به اصطلاح `VLAN` مورد نظر را به آن اختصاص داده و نگاشت می‌کنیم.
* در مرحله بعد با دستور `Router(config-subif)#encapsulation dot1Q ${vlan-id like 10}` که از پروتکل `dot1Q` برای `InterVlan Routing` بهره میگیرد.
* با اجرای دستور فوق `Sub Interface` مورد نظر را مسئول `InterVlan Routing` برای `VLAN` مد نظر قرار دادیم.
* و به عنوان مرحله آخر می‌بایست به `Sub Interface` یک `IP` نیز اختصاص دهیم.
* بعد از `IP`دهی به `Sub Interface`ها نیازی به وارد کردن دستور `no shutdown` نیست چرا که این `Interface`ها مجازی هستند.
* بعد از اتمام تمام مراحل فوق با وارد کردن دستور `show running-config` از صحت انجام تمامی مراحل اطمینان حاصل می‌کنیم.
* اگر تمام تنظیمات به درستی وارد شده باشند اکنون باید بتوانیم از `VLAN`های مختلف یکدیگر را `Ping` بگیریم.
* تنظیمات `VLAN` تا اینجا به اتمام رسید.
* با وارد کردن دستور در کامپیوترها `PC> tracert ${destination-IP}` می‌توانیم مسیری که بین کامیپوترها برای پینگ گرفتن طی می‌شود را مشاهده کنیم.
* به ازای هر 1 `VLAN` می‌بایست 1 `Sub Interface` داشته باشیم.

> نکته‌ای که بسیار حائز اهمیت هست این است که در صورت ترکیب `VLAN` با مسیریابی سایر `Router`ها باید دقیقا مانند همان حالتی که زیر شبکه های عادی را به `Router` ها معرفی می‌کردیم در قالب `network` می‌بایست تمام `VLAN`های یک `Router` را نیز تحت عنوان `network` برای پروتکل مسیریابی مورد نظر در `Router` مربوطه وارد کنیم.

* به طور کلی حتی با وجود اینکه زیرشبکه‌های مجازی قابل مشاهده نیستند باید به عنوان زیرشبکه شناخته شوند و همان واکنشی که در عملیات های گوناگون نسبت به زیرشبکه‌ها داریم نسبت به زیر‌شبکه‌های مجازی نیز داشته باشیم.
* فلسفه اتصال توسط `Router` و عدم اتصال توسط `Switch` در `VLAN`ها این است که `Router` اعمال ملاحظات امنیتی بیشتری می‌تواند داشته باشد.

> نکته‌ی بسیار مهم دیگر این است که در صورتی که ابتدا یک توپولوژی راه اندازی شد و سپس تصمیم بر تغییر آن جهت راه اندازی `VLAN` شد حتما حتما باید `Default Gateway`ها را تغییر بدهیم به `Sub Interface`های مورد نظر.

* اضافه کردن یک کامپیوتر به یک `VLAN` موجود تمرین شود.